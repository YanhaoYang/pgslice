#!/usr/bin/env ruby

require "thor"
require "pgslice/commands"

class PgSliceCommand < Thor
  def self.exit_on_failure?
    true
  end

  class_option :url, type: :string, desc: "A PostgreSQL connection string"
  class_option :strategy, type: :string, required: true, desc: "A strategy class defining the partion strategy"
  class_option :table, type: :string, required: true, desc: "The table to be partitioned"

  desc "prep", "create intermediate table and relating triggers"
  def prep
    PgSlice::Prep.new(options).run
  end

  desc "add_partitions TABLE", "add_partitions to TABLE, e.g. pgslice add_partitions visits --intermediate --past 1 --future 1"
  option :intermediate, type: :boolean
  option :series, type: :string, required: true
  def add_partitions(table)
    PgSlice::AddPartitions.new(table, options).run
  end

  desc "fill TABLE", "fill TABLE with original data"
  option :batch_by, type: :string, desc: "the column name of which will be used to batch data"
  option :starting_value, type: :string, desc: "specify a start value, otherwise it will be computed from exsiting data"
  option :source_table, type: :string
  option :dest_table, type: :string
  option :where, type: :string
  option :swapped, type: :boolean, desc: "source table and destination table have been swapped."
  def fill(table)
    PgSlice::Fill.new(table, options).run
  end

  desc "unprep TABLE", "unprepare the TABLE"
  def unprep(table)
    PgSlice::Unprep.new(table, options).run
  end

  desc "analyze TABLE", "analyze the TABLE and print out information about partition tables"
  def analyze(table)
    PgSlice::Analyze.new(table, options).run
  end

  desc "swap TABLE", "swap the TABLE with the intermediate table"
  option :lock_timeout, type: :numeric, default: 30, desc: "timeout in seconds"
  def swap(table)
    PgSlice::Swap.new(table, options).run
  end

  desc "unswap TABLE", "unswap the TABLE with the intermediate table"
  def unswap(table)
    PgSlice::Unswap.new(table, options).run
  end
end

PgSliceCommand.start
