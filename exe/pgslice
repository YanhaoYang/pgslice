#!/usr/bin/env ruby

require "thor"
require "pgslice/commands"

class PgSliceCommand < Thor
  def self.exit_on_failure?
    true
  end

  class_option :url, type: :string, desc: "A PostgreSQL connection string"
  class_option :strategy, type: :string, required: true, desc: "A strategy class defining the partion strategy"
  class_option :table, type: :string, required: true, desc: "The table to be partitioned"

  desc "prep", "create intermediate table and relating triggers"
  def prep
    PgSlice::Commands::Prep.new(options).run
  end

  desc "add_partitions", "add partitions to the table"
  def add_partitions
    PgSlice::Commands::AddPartitions.new(options).run
  end

  desc "enable_sync", "add triggers to keep source table and intermediate table in synch"
  def enable_sync
    PgSlice::Commands::EnableSync.new(options).run
  end

  desc "fill TABLE", "fill TABLE with original data"
  option :starting_value, type: :string, desc: "specify a start value, otherwise it will be computed from exsiting data"
  option :batch_size, type: :numeric, default: 1000, desc: "the number of records in each batch"
  def fill
    PgSlice::Commands::Fill.new(options).run
  end

  desc "unprep", "remove intermediate table and relating triggers"
  def unprep
    PgSlice::Commands::Unprep.new(options).run
  end

  desc "analyze TABLE", "analyze the TABLE and print out information about partition tables"
  def analyze(table)
    PgSlice::Analyze.new(table, options).run
  end

  desc "swap TABLE", "swap the TABLE with the intermediate table"
  option :lock_timeout, type: :numeric, default: 30, desc: "timeout in seconds"
  def swap(table)
    PgSlice::Swap.new(table, options).run
  end

  desc "unswap TABLE", "unswap the TABLE with the intermediate table"
  def unswap(table)
    PgSlice::Unswap.new(table, options).run
  end
end

PgSliceCommand.start
